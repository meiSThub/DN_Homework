抽象工厂（Abstract Factory）：提供一个创建一系列相关或相互依赖对象的接口，而无须指定他们具体的类。

uml图解析：
抽象工厂（Abstract Factory）角色：担任这个角色的是工厂方法模式的核心，它是与应用系统商业逻辑无关的。
具体工厂（Concrete Factory）角色：这个角色直接在客户端的调用下创建产品的实例。这个角色含有选择合适
        的产品对象的逻辑，而这个逻辑是与应用系统的商业逻辑紧密相关的。
抽象产品（Abstract Product）角色：担任这个角色的类是工厂方法模式所创建的对象的父类，或它们共同拥有的接口。
具体产品（Concrete Product）角色：抽象工厂模式所创建的任何产品对象都是某一个具体产品类的实例。
        这是客户端最终需要的东西，其内部一定充满了应用系统的商业逻辑。
可以参考abstract_factory_understand.png辅助理解。

案例代码说明：
    不同产品等级：Sqlserver数据库，Access数据库
    不同产品族：Sqlserver数据库中，操作用户表（SqlserverUserDao）,部门表（SqlserverDepartmentDao)。
               Access数据库中，操作用户表（AccessUserDao),部门表（AccessDepartmentDao)。
               即SqlserverUserDao和AccessUserDao属于同一个产品族，


1、抽象工厂模式的优点：
        抽象工厂模式除了具有工厂方法模式的优点外，最主要的优点就是可以在类的内部对产品族进行约束。
所谓的产品族，一般或多或少的都存在一定的关联，抽象工厂模式就可以在类内部对产品族的关联关系进行定义
和描述，而不必专门引入一个新的类来进行管理。

2、抽象工厂模式的缺点：
       产品族的扩展将是一件十分费力的事情，假如产品族中需要增加一个新的产品，则几乎所有的工厂类
都需要进行修改。所以使用抽象工厂模式时，对产品等级结构的划分是非常重要的。

3、适用场景：
       当需要创建的对象是一系列相互关联或相互依赖的产品族时，便可以使用抽象工厂模式。说的更明白一点，
就是一个继承体系中，如果存在着多个等级结构（即存在着多个抽象类），并且分属各个等级结构中的实现类之间
存在着一定的关联或者约束，就可以使用抽象工厂模式。假如各个等级结构中的实现类之间不存在关联或约束，
则使用多个独立的工厂来对产品进行创建，则更合适一点。